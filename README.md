# Network Synchronization of Lorenz Oscillators

This repository contains **MATLAB** and **Python** code for simulating and visualizing the synchronization of a network of coupled Lorenz oscillators.  
The project demonstrates the application of **graph theory**‚Äîspecifically weighted Laplacian matrices and vertex imbalances‚Äîto achieve and analyze network synchronization.

---

## üìñ Project Overview
The core of this project lies in a set of MATLAB scripts that model and simulate a network of chaotic Lorenz oscillators.  

- The **`SyncCouplingAssign`** function implements a method to assign coupling weights that guarantee synchronization of the network.  
- A **Jupyter Notebook** (`synchronization_plot.ipynb`) is provided for visualizing the simulation results.

---

## üìÇ File Descriptions

### MATLAB Scripts
- **`CoupledDynamics.m`**  
  Defines the coupled network dynamics for MATLAB‚Äôs `ode45` solver. Computes the system‚Äôs time derivative by combining individual Lorenz dynamics and diffusive coupling.

- **`CycleBasisVector.m`**  
  Updates edge weights of a strongly connected digraph to ensure all edges have non-zero weights while preserving vertex imbalances.

- **`LCSS_synchronization_plot.m`**  
  Main script: sets up the Lorenz network, defines the graph, runs the simulation with `SimulateCoupledSystems`, and plots synchronization error over time.  
  Exports results to **`sync_data.xlsx`**.

- **`LorenzOscillator.m`**  
  Defines the ODEs for a single Lorenz oscillator.

- **`NegativeImbalanceVectorSCC.m`**  
  Assigns edge weights within a strongly connected component to ensure **all vertex imbalances are negative**, a key condition for synchronization.

- **`SimulateCoupledSystems.m`**  
  Main simulation function. Uses `ode45` to solve the coupled system dynamics. Builds the **weighted Laplacian matrix**.

- **`SyncCouplingAssign.m`**  
  Core function that assigns coupling strengths. Takes a digraph and parameter `a` to modify edge weights, ensuring synchronization conditions are satisfied.

- **`VertexImbalancePlot.m`**  
  Visualization script that computes the vertex imbalance vector and plots the graph with edge weights and imbalance values as labels.

---

### Python Jupyter Notebook
- **`synchronization_plot.ipynb`**  
  Visualizes the data generated by `LCSS_synchronization_plot.m`.  
  - Loads **`sync_data.xlsx`**  
  - Plots synchronization error of each oscillator  
  - Saves results as **PDF** and **EPS** figures  

---

## üöÄ Getting Started

### Prerequisites
- **MATLAB** (with Graph and Network Algorithms toolbox)  
- **Python** (with Jupyter Notebook and packages: `pandas`, `matplotlib`, `numpy`)  

### Usage
1. **Simulate in MATLAB**  
   Run `LCSS_synchronization_plot.m`  
   ‚Üí Generates simulation data and **`sync_data.xlsx`**  

2. **Visualize in Python**  
   Open `synchronization_plot.ipynb` in Jupyter (or Google Colab).  
   Ensure `synchronization_data.xlsx` is accessible.  
   Run the notebook cells to produce synchronization plots.  

---

## üìä Example Workflow
1. Define your directed graph and oscillator parameters in MATLAB.  
2. Run the main script ‚Üí simulation data is saved.  
3. Use the notebook to generate clean plots for reports or publications.  

---

## üìå Notes
- The **Lorenz attractor** can be replaced with **any dynamical system** with its **one-sided Lipschitz parameter (or QUAD parameter)** as the parameter **a**.  
- The **digraph topology** can also be modified, but it must remain at least **weakly connected** to ensure synchronization feasibility.  
- This framework generalizes beyond Lorenz oscillators to a wide class of coupled dynamical systems.  

---

## üñãÔ∏è Author
Developed as part of research on **dynamical networks, synchronization, and graph-theoretic methods in control systems**.  

---

## üìú License
This project is licensed under the [MIT License](LICENSE).  
